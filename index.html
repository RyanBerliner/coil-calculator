<form style="margin: 1rem 0;">
  <label style="display: block">
    Rider Weight (lbs)
    <input type="number" name="rider-weight" value="165">
  </label>
  <label style="display: block">
    Rear wheel travel (mm)
    <input type="number" name="travel" value="160">
  </label>
  <label style="display: block">
    Shock stroke (mm)
    <input type="range" name="stroke" value="60" min="15" max="120">
  </label>
  <label style="display: block; margin-top: 1rem;">
    Sag (%)
    <input type="number" name="sag" value="27">
  </label>
  <label style="display: block">
    Spring Weight (lbs/in)
    <input type="number" name="spring-weight" value="0">
  </label>
</form>

<button id="simulate">press & hold to simulate sag</button>

<canvas></canvas>

<script>
  const sagInput = document.querySelector('input[name="sag"]');
  const springWeightInput = document.querySelector('input[name="spring-weight"]');
  const form = document.querySelector('form');
  const button = document.getElementById('simulate');

  let riderWeight = 0;
  let wheelTravel = 0;
  let stroke = 0;
  let sag = 0;
  let springWeight = 0;
  let solveFor = 'weight';
  let simulating = false;
  
  document.addEventListener('input', function(event) {
    if (event.target.getAttribute('name') === 'sag') solveFor = 'weight';
    else solveFor = 'sag';
    calculateCharacteristics();
  });

  button.addEventListener('mousedown', () => simulating = true);
  button.addEventListener('mouseup', () => simulating = false);

  form.addEventListener('submit', function(event) {
    event.preventDefault();
    calculateCharacteristics();
  });

  function calculateCharacteristics() {
    const data = new FormData(form);
    riderWeight = parseInt(data.get('rider-weight'));
    wheelTravel = parseInt(data.get('travel'));
    stroke = parseInt(data.get('stroke'));
    sag = parseInt(data.get('sag'));
    springWeight = parseInt(data.get('spring-weight'));

    const leverage = wheelTravel / stroke;
    // TODO: add in (part of) average weight of the bike itself?
    const rearTireBias = 0.65; // the rear wheel supports 65% of the riders weight
    const normWeight = riderWeight  * leverage * rearTireBias;

    // hooks law to solve for the spring rate
    // F = k*x
    // F   force
    // k   spring rate
    // x   deformation (sometimes called displacement)

    if (solveFor === 'weight') {
      const targetSagDistance = stroke * sag / 100;
      springWeight = normWeight / targetSagDistance; // lbs/mm
      springWeight *= 25.4 // lbs/in
      springWeight = parseInt(springWeight);
      springWeightInput.value = springWeight;
    } else {
      sag = normWeight / springWeight; // in
      sag *= 25.4 // mm
      sag /= stroke / 100 // %
      sag = Math.round(sag * 100) / 100; // round to 2 decimals (so users can see something is changing
      sagInput.value = sag;
    }
  }

  calculateCharacteristics();

  // the rest is the animation

  const canvasNode = document.querySelector('canvas');
  canvasNode.height = 700;
  canvasNode.width = 700;

  const context = canvasNode.getContext('2d');

  function drawShock(stroke, compression) {
    context.fillStyle = '#efefef';
    context.fillRect(0, 0, canvasNode.width, canvasNode.height);

    // all in mm
    const originalCoilHeight = stroke * 2.33;
    const coilHeight = originalCoilHeight - compression;
    const coilThickness = 8;
    const coilWidth = 52;
    const coilCount = (stroke - (stroke % 12)) / 12;
    const shaftWidth = 13;
    const bumpStopWidthBottom = 29;
    const bumpStopWidthTop = 25;
    const bumpStopHeight = 22;
    const bumpStopSquish = 10;
    const trueShaftHeight = stroke + (bumpStopHeight - bumpStopSquish);
    const preloadWidth = 33;
    const plateThickness = coilThickness / 1.3;
    const bottomMountCenterHole = 20;
    const bottomMountWidth = 21;
    const mountRadius = 6;
    const topMountCenterHole = 17;
    const topMountRadius = 4;
    const bushingWidth = 2;
    const preloadHeight = stroke * 1.2;
    const coilBG = '#d46633';
    const coilFG = '#f07909';

    // we want to draw this in the center of the canvas
    context.translate(canvasNode.width / 2, canvasNode.height / 2);
    let middleTransform = context.getTransform();

    // the background coils
    context.translate(coilWidth / -2, -coilHeight);
    context.lineWidth = coilThickness;
    context.lineCap = 'round';
    context.beginPath();
    context.strokeStyle = coilBG;
    let coilGap = coilHeight / (coilCount + 0.5);
    for (let i = 0; i <= coilCount; i++) {
      let coilStartY = i * coilGap;
      let coilEndY = coilStartY + coilGap / 2;
      let deltaY = coilEndY - coilStartY;
      context.moveTo(0, coilStartY);
      const funcY = x => -0.5 * coilWidth * Math.cos(Math.PI * (1 / deltaY) * x);

      for (let x = 0; x <= deltaY; x += 1) {
        const y = funcY(x);
        context.lineTo(y + coilWidth / 2, coilStartY + x);
      }

      context.lineTo(coilWidth, coilStartY + deltaY);
      context.stroke();
    }
    context.setTransform(middleTransform);

    // draw the shaft in the middle
    context.translate(shaftWidth / -2, -trueShaftHeight);
    context.beginPath();
    context.fillStyle = 'lightgrey';
    context.fillRect(0, 0, shaftWidth, trueShaftHeight);
    context.setTransform(middleTransform);

    // bump stop
    context.fillStyle = 'black';
    context.translate(bumpStopWidthBottom / -2, -bumpStopHeight);
    context.beginPath();
    context.moveTo((bumpStopWidthBottom - bumpStopWidthTop) / 2, 0);
    context.lineTo((bumpStopWidthBottom - bumpStopWidthTop) / 2 + bumpStopWidthTop, 0);
    context.lineTo(bumpStopWidthBottom, bumpStopHeight);
    context.lineTo(0, bumpStopHeight);
    context.fill();
    context.setTransform(middleTransform);

    // top preload cylinder 
    context.translate(preloadWidth / -2, -coilHeight - preloadHeight / 2);
    context.lineWidth = 3;
    context.strokeStyle = 'black';
    context.beginPath();
    context.moveTo(0,0);
    for (let i = 0; i <= preloadHeight; i++) {
      context.moveTo(i % 6 === 0 ? -2 : 0, 1 * i);
      context.lineTo(preloadWidth + (i % 6 === 0 ? 2 : 0), 1 * i);
    }
    context.stroke();

    // top preload cylinder (bottom part)
    const pcBottomHeight = originalCoilHeight - trueShaftHeight - preloadHeight / 2;
    context.translate(0, preloadHeight);
    context.beginPath();
    context.moveTo(0, 0);
    context.lineTo(preloadWidth, 0);
    context.lineTo(preloadWidth, pcBottomHeight * 0.9);
    context.lineTo(preloadWidth * 0.9, pcBottomHeight);
    context.lineTo(preloadWidth * 0.1, pcBottomHeight);
    context.lineTo(0, pcBottomHeight * 0.9);
    context.lineTo(0, 0);
    context.fill();
    context.setTransform(middleTransform);

    const topOfMount = -topMountRadius - bushingWidth * 2;
    const mountWidth = (coilWidth * 3 + preloadWidth) / 4;
    const rounding = 3;

    context.translate(-mountWidth / 2, -coilHeight - preloadHeight / 2 - topMountCenterHole);
    context.beginPath();
    context.moveTo(0, 0);
    context.arcTo(mountWidth / 2 - topMountRadius - bushingWidth / 2, topOfMount, mountWidth / 2 + topMountRadius + bushingWidth / 2, topOfMount, rounding);
    context.arcTo(mountWidth / 2 + topMountRadius + bushingWidth / 2, topOfMount, mountWidth, 0, rounding);
    context.arcTo(mountWidth, 0, mountWidth, topMountCenterHole, rounding);
    context.arcTo(mountWidth, topMountCenterHole, 0, topMountCenterHole, rounding);
    context.arcTo(0, topMountCenterHole, 0, 0, rounding);
    context.arcTo(0, 0, mountWidth / 2 - topMountRadius - bushingWidth / 2, topOfMount, rounding);
    context.fill();

    context.beginPath();
    context.lineWidth = bushingWidth;
    context.strokeStyle = 'white';
    context.arc(mountWidth / 2, 0, topMountRadius, 2 * Math.PI, false);
    context.stroke();

    context.setTransform(middleTransform);

    // the foreground coils
    context.translate(coilWidth / -2, -coilHeight);
    context.beginPath();
    context.lineWidth = coilThickness;
    context.strokeStyle = coilFG;
    for (let i = 1; i <= coilCount; i++) {
      let coilStartY = i * coilGap;
      let coilEndY = coilStartY - coilGap / 2;
      let deltaY = coilEndY - coilStartY;
      context.moveTo(0, coilStartY);
      const funcY = x => -0.5 * coilWidth * Math.cos(Math.PI * (1 / deltaY) * x);

      for (let x = 0; x >= deltaY; x -= 1) {
        const y = funcY(x);
        context.lineTo(0 + y + coilWidth / 2, coilStartY + x);
      }

      context.lineTo(coilWidth, coilStartY + deltaY);
      context.stroke();
    }

    // the top edge
    context.beginPath();
    context.strokeStyle = coilFG;
    context.moveTo(0, 0);
    context.lineTo(coilWidth, 0);
    context.stroke();

    // draw the plate on the top
    context.translate(-coilThickness / 2, -plateThickness);
    context.beginPath();
    context.fillStyle = 'black';
    context.fillRect(0, 0, coilWidth + coilThickness, plateThickness);
    context.setTransform(middleTransform);

    // the bottom edge
    context.translate(-coilWidth / 2, 0);
    context.beginPath();
    context.moveTo(0, 0);
    context.lineTo(coilWidth, 0);
    context.stroke();


    // draw the plate on the bottom
    context.translate(-coilThickness / 2, 0);
    context.beginPath();
    context.fillStyle = 'black';
    context.fillRect(0, 0, coilWidth + coilThickness, plateThickness);
    context.setTransform(middleTransform);

    // bottom mount
    context.translate(bottomMountWidth / -2, 0);
    context.beginPath();
    context.fillStyle = 'black';

    context.moveTo(0,0);
    context.lineTo(bottomMountWidth, 0);
    const outerRadius = bottomMountWidth / 2;

    context.arcTo(bottomMountWidth, bottomMountCenterHole + outerRadius, 0, bottomMountCenterHole + outerRadius, outerRadius);
    context.arcTo(0, bottomMountCenterHole + outerRadius, 0, 0, outerRadius);

    context.moveTo(bottomMountWidth / 2, bottomMountCenterHole);
    context.arc(bottomMountWidth / 2, bottomMountCenterHole, mountRadius, 2 * Math.PI, false);

    context.fill('evenodd');
    context.setTransform(middleTransform);


    context.beginPath();
    context.strokeStyle = 'tan';
    context.lineWidth = bushingWidth;
    context.arc(0, bottomMountCenterHole, mountRadius, 2 * Math.PI, false);
    context.stroke();

    context.resetTransform();
  }

  function doPhysics() {
    context.clearRect(0, 0, canvasNode.width, canvasNode.height);
    drawShock(stroke, 0);
    context.resetTransform();
    context.font = '12px arial';
    context.fillText(`Simulating: ${simulating ? 'true' : 'false'}`, 0, 12);
    requestAnimationFrame(doPhysics);
  }

  requestAnimationFrame(doPhysics);

</script>
