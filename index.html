<form style="margin: 1rem 0;">
  <label style="display: block">
    Rider Weight (lbs)
    <input type="number" name="rider-weight" value="165">
  </label>
  <label style="display: block">
    Rear wheel travel (mm)
    <input type="number" name="travel" value="160">
  </label>
  <label style="display: block">
    Shock stroke (mm)
    <input type="number" name="stroke" value="60">
  </label>
  <label style="display: block; margin-top: 1rem;">
    Sag (%)
    <input type="number" name="sag" value="27">
  </label>
  <label style="display: block">
    Spring Weight (lbs/in)
    <input type="number" name="spring-weight" value="0">
  </label>
</form>

<canvas></canvas>

<script>
  const sagInput = document.querySelector('input[name="sag"]');
  const springWeightInput = document.querySelector('input[name="spring-weight"]');
  const form = document.querySelector('form');

  let riderWeight = 0;
  let wheelTravel = 0;
  let stroke = 0;
  let sag = 0;
  let springWeight = 0;
  let solveFor = 'weight';
  
  document.addEventListener('change', function(event) {
    if (event.target.getAttribute('name') === 'sag') solveFor = 'weight';
    else solveFor = 'sag';
    calculateCharacteristics();
  });

  form.addEventListener('submit', function(event) {
    event.preventDefault();
    calculateCharacteristics();
  });

  function calculateCharacteristics() {
    const data = new FormData(form);
    riderWeight = parseInt(data.get('rider-weight'));
    wheelTravel = parseInt(data.get('travel'));
    stroke = parseInt(data.get('stroke'));
    sag = parseInt(data.get('sag'));
    springWeight = parseInt(data.get('spring-weight'));

    const leverage = wheelTravel / stroke;
    // TODO: add in (part of) average weight of the bike itself?
    const rearTireBias = 0.65; // the rear wheel supports 65% of the riders weight
    const normWeight = riderWeight  * leverage * rearTireBias;

    // hooks law to solve for the spring rate
    // F = k*x
    // F   force
    // k   spring rate
    // x   deformation (sometimes called displacement)

    if (solveFor === 'weight') {
      const targetSagDistance = stroke * sag / 100;
      springWeight = normWeight / targetSagDistance; // lbs/mm
      springWeight *= 25.4 // lbs/in
      springWeight = parseInt(springWeight);
      springWeightInput.value = springWeight;
    } else {
      sag = normWeight / springWeight; // in
      sag *= 25.4 // mm
      sag /= stroke / 100 // %
      sag = Math.round(sag * 100) / 100; // round to 2 decimals (so users can see something is changing
      sagInput.value = sag;
    }
  }

  calculateCharacteristics();

  // the rest is the animation

  const canvasNode = document.querySelector('canvas');
  canvasNode.height = 700;
  canvasNode.width = 700;

  const context = canvasNode.getContext('2d');

  context.fillStyle = '#efefef';
  context.fillRect(0, 0, canvasNode.width, canvasNode.height);


  const coilThickness = 20;
  const coilWidth = 120;
  const coilHeight = 380;
  const coilCount = 6;
  const coilBG = '#d46633';
  const coilFG = '#f07909';

  // we want to draw this in the center of the screen
  context.translate(350 - coilWidth / 2, 350 - coilHeight / 2);
  let middleTransform = context.getTransform();

  // the background coils
  context.lineWidth = coilThickness;
  context.lineCap = 'round';
  context.beginPath();
  context.strokeStyle = coilBG;
  let coilGap = coilHeight / (coilCount + 0.5);
  for (let i = 0; i <= coilCount; i++) {
    let coilStartY = i * coilGap;
    let coilEndY = coilStartY + coilGap / 2;
    let deltaY = coilEndY - coilStartY;
    context.moveTo(0, coilStartY);
    const funcY = x => -0.5 * coilWidth * Math.cos(Math.PI * (1 / deltaY) * x);

    for (let x = 0; x <= deltaY; x += 1) {
      const y = funcY(x);
      context.lineTo(y + coilWidth / 2, coilStartY + x);
    }

    context.lineTo(coilWidth, coilStartY + deltaY);
    context.stroke();
  }

  // draw the shaft in the middle
  const shaftWidth = 24;
  context.translate(coilWidth / 2 - shaftWidth / 2, 0);
  context.beginPath();
  context.fillStyle = 'lightgrey';
  context.fillRect(0, 0, shaftWidth, coilHeight);
  context.setTransform(middleTransform);

  // bump stop
  const bumpStopWidthBottom = coilWidth * 0.7;
  const bumpStopWidthTop = coilWidth * 0.5;
  const bumpStopHeight = 60;
  context.fillStyle = 'black';
  context.translate(coilWidth / 2 - bumpStopWidthBottom / 2, coilHeight - bumpStopHeight);
  context.beginPath();
  context.moveTo((bumpStopWidthBottom - bumpStopWidthTop) / 2, 0);
  context.lineTo((bumpStopWidthBottom - bumpStopWidthTop) / 2 + bumpStopWidthTop, 0);
  context.lineTo(bumpStopWidthBottom, bumpStopHeight);
  context.lineTo(0, bumpStopHeight);
  context.fill();
  context.setTransform(middleTransform);

  // top preload cylinder 
  const pcWidth = coilWidth * 0.75;
  const pcHeight = 180;
  context.translate(coilWidth / 2 - pcWidth / 2, pcHeight / -2);
  context.lineWidth = 3;
  context.strokeStyle = 'black';
  context.beginPath();
  context.moveTo(0,0);
  for (let i = 0; i <= pcHeight; i++) {
    context.moveTo(i % 6 === 0 ? -2 : 0, 1 * i);
    context.lineTo(pcWidth + (i % 6 === 0 ? 2 : 0), 1 * i);
  }
  context.stroke();

  // top preload cylinder (bottom part)
  const pcBottomHeight = 110;
  context.translate(0, pcHeight);
  context.beginPath();
  context.moveTo(0, 0);
  context.lineTo(pcWidth, 0);
  context.lineTo(pcWidth, pcBottomHeight * 0.9);
  context.lineTo(pcWidth * 0.9, pcBottomHeight);
  context.lineTo(pcWidth * 0.1, pcBottomHeight);
  context.lineTo(0, pcBottomHeight * 0.9);
  context.lineTo(0, 0);
  context.fill();
  context.setTransform(middleTransform);

  // the foreground coils
  context.beginPath();
  context.lineWidth = coilThickness;
  context.strokeStyle = coilFG;
  for (let i = 1; i <= coilCount; i++) {
    let coilStartY = i * coilGap;
    let coilEndY = coilStartY - coilGap / 2;
    let deltaY = coilEndY - coilStartY;
    context.moveTo(0, coilStartY);
    const funcY = x => -0.5 * coilWidth * Math.cos(Math.PI * (1 / deltaY) * x);

    for (let x = 0; x >= deltaY; x -= 1) {
      const y = funcY(x);
      context.lineTo(0 + y + coilWidth / 2, coilStartY + x);
    }

    context.lineTo(coilWidth, coilStartY + deltaY);
    context.stroke();
  }

  // the top edge
  context.beginPath();
  context.strokeStyle = coilFG;
  context.moveTo(0, 0);
  context.lineTo(coilWidth, 0);
  context.stroke();

  // the bottom edge
  context.moveTo(0, coilHeight);
  context.lineTo(coilWidth, coilHeight);
  context.stroke();

  // draw the plate on the bottom
  const extraWidth = 20;
  const bottomPlateHeight = 10;
  context.translate(extraWidth / -2, coilHeight);
  context.beginPath();
  context.fillStyle = 'black';
  context.fillRect(0, 0, coilWidth + extraWidth, bottomPlateHeight);
  context.setTransform(middleTransform);

  // draw the plate on the top
  const topPlateHeight = 20;
  context.translate(extraWidth / -2, topPlateHeight / -2 - coilThickness / 2);
  context.beginPath();
  context.fillStyle = 'black';
  context.fillRect(0, 0, coilWidth + extraWidth, topPlateHeight);
  context.setTransform(middleTransform);

  // bottom mount
  const bottomMountWidth = 65;
  const bottomMountHeight = 40;
  const holeRadius = 20;
  context.translate(coilWidth / 2 - bottomMountWidth / 2, coilHeight + bottomPlateHeight);
  context.beginPath();
  context.fillStyle = 'black';

  context.moveTo(0,0);
  context.lineTo(bottomMountWidth, 0);
  context.arcTo(bottomMountWidth, bottomMountHeight + bottomMountWidth / 2, 0, bottomMountHeight + bottomMountWidth / 2, bottomMountWidth / 2);
  context.arcTo(0, bottomMountHeight + bottomMountWidth / 2, 0, 0, bottomMountWidth / 2);

  context.moveTo(bottomMountWidth / 2, bottomMountHeight);
  context.arc(bottomMountWidth / 2, bottomMountHeight, holeRadius, 2 * Math.PI, false);

  context.fill('evenodd');

  context.beginPath();
  context.strokeStyle = 'tan';
  context.lineWidth = 5;
  context.arc(bottomMountWidth / 2, bottomMountHeight, holeRadius, 2 * Math.PI, false);
  context.stroke();

  context.setTransform(middleTransform);


</script>
